# 简单工厂模式
```txt
    简单工厂模式（Simple Factory Pattern）是指由工厂对象绝对创建出哪一种产品类的实例，
但是它不属于GOF23钟设计模式。简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要
传入工厂参数，对于如果创建对象的逻辑不需要关心。

参考：Calendar#.getInstance()

缺点：
1. 工厂的指责相对过重，不利于扩展 过于复杂的产品结构
```

# 工厂方法模式
```$xslt
    工厂方法模式（Fatory Method Pattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，
工厂方法让类的实例化推迟到自类中进行。在工厂方法模式中用户只需要关心所需产品的对应的工厂，无需关心创建细节，
而且加入新的产品符合开闭原则。
    工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑有区别，工厂的指责
会变的越来越多，有点万能工厂的趋势，并不便于维护。根据单一指责原则我们将职能继续拆分，专人干专事。
A业务由A业务工厂创建，B业务由B业务工厂创建，对于工厂本身也做一个抽象。
参考：LoggerFatory#getLogger

适用场景：
1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建，实现等细节/
3. 一个类通过其子类来指定创建那个对象

缺点：
1. 类的个数容易过多，增加复杂度
2. 增加了系统的抽象性和理解难度
```

# 抽象工厂模式
```$xslt
    抽象工厂模式（Abstract Factory Pattren）是提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。
客户端（应用层）不依赖产品类实例如何被创建，实现等细节，强调的是一系列相关的产品对象（属于同一产品）一起使用创建
对象需要大量重复的代码。需要提供一个产品类的库，所有的对象以同样的接口实现，从而使客户端不依赖具体的实现。

缺点：
1。 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
2。 增加了系统的抽象性和理解难度
```

# 单例模式
```$xslt
   单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。
单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。

属于创建型模式。

参考：ServletContxt，ServletCOntextConfig，ApplicationContext
```

# 原型模式
```$xslt
    原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
调用者不需要知道任何创建细节，不调用构造函数。

属于创建型模式
```

# 建造者模式
```$xslt
    建造者模式（Builder pattern）是将一个复杂对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示。

特征：用户只需要指定需要建造的类型就可以获得对象，建造过程及细节不需要了解。

属于创建型模式。

适用场景：
1。 适用于创建对象需要很多步骤，但是步骤的不一定固定。
2。 如果一个对象有非常复杂的内部结构（很多属性）。
3。 把复杂对象的创建和适用分离

建造者将创建对象步骤开发，注重步骤过程的定制，原型模式创建对象步骤不开放。

建造者模式与工厂模式区别：
1， 建造者模式更加注重方法的调用顺序，工厂模式注重与创建对象。
2， 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。
3， 关注点：工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。
4，建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。
```

# 代理模式
```$xslt
   代理模式（Proxy pattern）是指为其他对象提供一种代理，以控制对这个对象的访问。

代理对象在客户端和目标对象之间起到中介作用。

优点：
代理模式能将代理对象与真实被调用的目标对象分离。
一定程度上降低了系统的耦合程度，易于扩展。
代理可以起到保护目标对象的作用。
增强目标对象的指责。

缺点：
代理模式会造成系统设计中类的数目增多
在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。
增加系统的复杂度

Spring中的代理选择原则
1， 当Bean有实现接口时，Spring就会用JDK的动态代理。
2， 当Bean没有实现接口时，Spring会选择CGLIB
3， Spring可以通过配置强制使用CGLIB，只需在Spring的配置文件中高加入如下代码：
<aop:aspectj-autoproxy proxy-target-class-"true"/>

静态代理和动态代理的区别？
静态代理：硬编码，手动注入，手动拿到目标对象的引用，手动调用代理目标的方法
动态代理：具有更强的扩展性，自动注入，自动生成一个新的类（同一个继承体系）
特征：
    拿到代理目标对象的引用
    实现功能增强
    保护目标对象

属于结构型模式。
```

# 门面模式
```$xslt
    门面模式（Facade Pattern）又叫做外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。

特征：门面模式定义一个高层接口，让子系统更容易使用
遵循迪米特法则，即最少知道原则

缺点：
当增加子系统和扩展子系统行为时，可能会带来风险
不符合开闭原则
默写情况下不可能违背单一指责原则

==门面模式和代理模式区别？
门面模式就是一个特殊的静态代理模式
委派模式（行为型模式，不属于GOF 23）也是一个静态代理模式（结构型模式）
门面模式重点在于封装，静态代理重点是在增强

==门面模式和单例模式区别？
门面模式做成单例模式，工具包

属于结构型模式。
```

# 装饰器模式
```$xslt
    装饰器模式（Decorator Pattern）也叫包装模式（Wrapper Pattern），
是指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）

适用场景：
1， 用于扩展一个类的功能或给一个类添加附加指责
2， 动态的给一个对象添加功能，这些功能可以再动态的撤销

装饰器模式和代理模式对比？
1， 装饰器模式就是一个特殊的代理模式
2， 装饰器模式强调自身的功能扩展
3， 代理模式强调代理过程的控制

缺点：
1， 会出现更多的代码，更多的类，增加程序的复杂性
2， 动态装饰时，多层装饰时更复杂

属于结构型模式
```
# 享元模式
```$sxlt
享元模式（Flyweight Pattern）又称为轻量级模式，是对象池的一种实现。类似于线程池，
线程池可以避免不停的创建和销毁多个对象消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。

宗旨：共享细粒度对象，将多个对同一个对象的访问集中起来。

考虑：内部状态和外部状态，关注哪些共享，哪些不是共享

场景：图书馆的书籍管理，
共享单车（内部状态：是否可用，颜色，款式。外部状态：是否被占用）

属于结构型模式
```

# 组合模式
```$sxlt
组合模式（Composite Pattern）也称为整体一部分（Part-Whole）模式

组合和聚合什么关系？
心在一起是团队，人在一起是团伙。团队是组合，团伙是聚合。
组合有一条主线，并且相同的声明周期，聚合学生属于这个老师的，学生入学的时候也是可以选择老师的
符合开闭原则
宗旨：通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示。

作用：使得客户端对单个对象和组合对象保持一直的方式处理

适用场景：
1，希望客户端可以忽略组合对象与单个对象的差异时
2，对象层次具备整体和部分，成树形结构（如树形菜单，操作系统目录结构，公司组织架构等）
3，

缺点：限制类型时候比较复杂

HashMap#putAll
ArrayList#addAll
SqlNode

属于结构型模式。
```














